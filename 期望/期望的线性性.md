#    期望的线性性

  CF上的解释为：  
### [Linearity of the Expected Value](https://assets.codeforces.com/statements/280-281/Tutorial.pdf)

  其实简单来说就是将一个期望的问题分解化，将答案E(V + U) 转化为 E(V) + E(U)
  先求出部分的答案，然后再将答案累加。
  这是一个对于求期望的十分重要的性质，因为经常情况下总体求是是十分困难的。

<span id="jump0"> </span>
#  title
##    [Glass Bead Game]
<br>
<br>
<br>

#   ⚾[Glass Bead Game](https://ac.nowcoder.com/acm/contest/32708/G)
![image](https://user-images.githubusercontent.com/92497177/167570169-70ed4a2f-02f0-424c-b364-3a97d65f7333.png)


    题意真的很好理解，但是做法真的是一点思路都没有。
    因为感觉在趋于无穷的时候，应该是按照概率的大小排下来的，那么答案就是很好计算的。
    但是这样算下来和正确答案并不一样，QAQ
    
    看了答案之后感觉真的还是对于期望的知识还要再学习很多才可以。
    
    
    这里是考虑对于每一对之间的贡献，因为我们计算对于一个物品拿起时，其贡献是多少，其实就是看
    他的前面有多少的物品，而我们只要算出对于当前这个物品其前面有多少个物品就是答案，
    但是我们发现这并不好算，因为考虑到m无穷大，那么我们可以分散的计算每一对的贡献，
    其实就是把上面的答案拆分了一下。
    因为如果有k个物品在其前面，那么是说明我们在那这个物品和这k个物品比的时候他们在他的前面。
    
    那么对于两个数  i,j
    在选择趋于无穷的时侯
    i在j前的概率是 pi * (pi + pj)
    j在i前的概率是 pj * (pj + pi)
    这其实是考虑了其他所有的数的情况下，因为我们需要将其他所有数都给排一下，那么其概率累加就是1
    又因为我们只需要考虑i,j的位置关系，所以就直接考虑他们的概率就可以了。
    
    那么这两的贡献是
    pj * (pi * (pi + pj)) + pi * (pj * (pi + pj))
    即i在j前的时候我们选择j,j在i前的时候我们选择i
    
    
    我们就只需要统计一下所有对的贡献就可以了
    
    
```C++
#include <bits/stdc++.h>

using namespace std;
using i64 = long long;
const int INF = 0x3f3f3f3f;

int main()
{
	int n;  scanf("%d",&n);
	vector<double>p(n + 1);
	for(int i = 1;i <= n ;i++)  scanf("%lf",&p[i]);
	
	double ans = 0;
	for(int i = 1; i <= n ;i++){
		for(int j = i + 1; j <= n ; j++){
			ans += 2 * p[i] * p[j] / (p[i] + p[j]);
		}
	}
	
	printf("%.15f",ans);
	return 0;
}
```


```diff
!    2022-05-10🍻
```
