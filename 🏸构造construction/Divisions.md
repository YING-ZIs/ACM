#   [Divisions](https://ac.nowcoder.com/acm/contest/32708/D)

  
  构造题还是得多练，这个真的是想了很久还是不会，大佬们的思想真的是令人羡慕！！
  
  这道题就是要不断的模拟才能找出规律！
  首先我们构造一个1，1的所有情况：   
  (第二个和第三个的1进入的顺序不同)   
  
  一共4种   
  ![image](https://user-images.githubusercontent.com/92497177/163841054-e583e83b-1d97-4e68-8f0d-9f43c240b640.png)
  
  那么我们现在往里面加 2试一下
  那我们新构造出来的情况就是在上面的情况中向A或是B中加2
  
  
  那么对于所有的情况我们都可以向A中加入2而构造出4组情况
  
  接下来就是向B里面加的：
  其实发现我们只能向空的那一个加，因为是降序排列而我们的2又大于1
  
  也就是说现在情况是：  
  一共5种   
  ![image](https://user-images.githubusercontent.com/92497177/163841924-aced1e94-c010-4046-a518-6a19df7a96b9.png)


  那么我们在考虑加进去一个2：
  
  我们还是可以向所有的A中加入2
  构造出5种
  
  对于B，其实我们只能向之前加2的和为空的。
  之前加过2的有1个， 1个为空
  所以加B能构造出来2种
  所以现在我们可以构造出来7种   
  ![image](https://user-images.githubusercontent.com/92497177/163842638-6b505c59-03a6-4c6f-99ef-1c4e8414a708.png)

  那么我们其实可以简单的推出我们加一个1使得答案加了1，加了第二个2的时候又加了2，那会不会是按照2进制去增长的了？
  
  当然的啦！！！
  
  我们考虑之前有x个1的集合现在要想其中加入2，
  我们其实可以把集合拆分为 (1 << x) - 1(B不为空的),   1(B为空的)
   
  那我们在集合的基础上就是向(1 << x) - 1中加入2是都可以的，那么我们此时构造出来 (1 << x) - 1个集合
  然后我们向那个空的集合的A和B加入2都是可以的。那么我们又构造出来2个集合。
  
  接下来再向其中加2，
  同理：那我们在集合的基础上就是向(1 << x) - 1中加入2是都可以的，那么我们此时构造出来 (1 << x) - 1个集合
  我们又向B为空以及B中只含有2的集合进行A,B操作都是可以的那就够造出来4个集合
  
  其实整体看我们其实向A中加入集合并不会让集合的个数增加，因为所有的集合都是可以向A中加的，关键是向B中加入，
  而可以加入的B一定为要么是空，要么是我们已经加入2的即为新构造出来的集合，
  所以每一次的加2操作就会让我们新构造出的集合翻一倍
  即为 + 1 , + 2 , + 4 , + 8
  所以即为增加 2 ^ x - 1
  所以我们就按照这个原则，
  
  但是只有一开始时会有特例，即为2，因为我们加进去一个就会产生2个，所以对于2我们特判一下
  然后将n--这样就可以保证答案正确了。
  
  
```C++
#include <bits/stdc++.h>

#define endll "\n"
using namespace std;
using i64 = long long;


int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	
	int k;  cin >> k;
	if(k == 0){
		cout << 5 << endl;
		cout << 10 << " " << 5 << " " << 7 << " " << 1 << " " << 3 << endl;
		return 0;
	} else if (k == 1) {
		cout << 6 << endl;
		cout << 1 << " " << 1 << " " << 4 << " " << 5 << " " <<  1 << " " << 4 << endl;
		return 0;
	}
	
	k--;
	int now = 1;
	vector<int>ans;
	while(k){
		int x = 1;
		while((1 << (x + 1)) - 1 <= k){
			x++;
		}
		k -= (1 << x) - 1;
		while(x--){
			ans.push_back(now);
		}
		now++;
	}
	
	cout << (int)ans.size() << endl;
	for(int i = 0 ; i < ans.size() ; i++){
		cout << ans[i] << " \n"[i == (int)ans.size() - 1]; 
	}
	
	return 0;
}
```
```diff
!    2022-04-19🛀
```

  
  
