<span id="jump0"> </span>
#  title

   ## [F. Four Column Hanoi Tower](#jump1)

#   🩹[King of Gamers](https://ac.nowcoder.com/acm/contest/32708/K)

  真的是没有这方面的思想，完全没有找到规律。。。。。。
  
  
  首先这道题暴力打表，我们来观察一下：
  
  ![image](https://user-images.githubusercontent.com/92497177/163835802-2231e503-f4d2-41b7-be88-1aff46b0c5fb.png)

 在某些位置需要我们去加1，但是这是什么时候呢？
 
  因为要加1，其实我们应该有这方面的一些想法，比如说进位。
  
  什么时候要进位？
  四舍五入， 向上取整， 或是针对于整数的向上取整？
  
  其实我们都可以去验证的，真的是没有一点经验，明明可以去一点一点的验证，因为猜结论无非就这些。
  
  
  而这次考的就是一个比较难想的整数的向上取整。
  
  将n - 1,然后直接输出 n * a / b + 1
  
  
  这里其实队友最后做出来的方法和这个就差不多了，我们都是要比一下n - 1 和 n 的效果。
  将n - 1的答案算一下，然后比一下此时的胜率再算用不用进位。
  
```C++
#include <bits/stdc++.h>

#define endl "\n"
using namespace std;
using i64 = long long;

int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	
	int t;  cin >> t;
	while(t--){
		
		i64 n, a, b;  cin >> n >> a >> b;
		n--;
		cout << n * a / b + 1 << endl;
	}
	return 0;
}
```
```diff
!   2022-04-19🏖️
```
<br>
<br>
<br>

[返回](#jump0)

<span id="jump1"> </span>

#    🥣[F. Four Column Hanoi Tower](https://codeforces.com/gym/103366/problem/F)

       这道汉诺塔的题目当时大一的时候就做过，但是现在看到的时候又忘记了。
       其实这道汉诺塔的题目就是三汉诺塔的一个简单变形。
       
       在三节汉诺塔里面，我们是将 n - 1个物品放在B个上面，再把第n个放在C上面，再把B上的n - 1个
       放到C上面。
       所以我们的递推公式是 h3[i] = h3[i - 1] * 2 + 1
       
       在这里我们是四个汉诺塔，理论上就会比三阶的步骤更少。
       我们还需要利用三阶的，我们假设取了x个那么这些上面的就是在4个上面都可以放的所以他们的步骤就是
       h4[x]，然后我们剩下的就只能在3个中来回移动了，因为下面的都比上面的那些大，不能放上去。
       那么我们就需要h3[n - x]使这些放在D上面，此时我们再去移动那些时，有可以随意移动了，因为他们是最小        的，那么再加一个h4[x]
       所以四阶汉诺塔的递推式为 h4[i] = min(h4[x] * 2 + h3[i - x])
       
       那么对于四阶我们只需要枚举一下x,然后去一个最小值就可以了。
       
       但是此时我们的时间复杂度是O(n²),这样是过不去的。
       
       这就是张队和孙队的恐怖，他们真的是在打表找规律，而我一个菜鸡当时真的不知道他们俩在干嘛，现在想想
       还是经验不足太菜了。
       
       
       对于那些计算量比较大的，没什么头绪的推公式题目，真的可以试着打表找一下规律而使其优化一下。
       
![image](https://user-images.githubusercontent.com/92497177/168708221-910a941b-6b5a-4370-8aa0-d7fa008d572d.png)

       我们暴力跑一下前1000的数他们取到最优解的值在哪里。
       不难发现到后面其实会取得一个和他离得很近的数，那么我们只需要玄学的取一个分数
       发现其实到1000时基本上就在其10/9以内了，那么我们就让其后面的9/10去更新就可以了。
        
       高精度太折磨人了，还是python更香
 
```python
h3 = [i for i in range(0, 10010)]

h3[1] = 1
for i in range(2, 10001):
    h3[i] = h3[i - 1] * 2 + 1

h4 =  [i for i in range(0, 10010)]
h4[1] = 1

for i in range(1, 1001):
    h4[i] = h3[i]
    for j in range(1, i):
        h4[i] = min(h4[i], 2 * h4[j] + h3[i - j])

for i in range(1001, 10010):

    h4[i] = h3[i]
    for j in range(i * 9 // 10, i):
        h4[i] = min(h4[i], 2 * h4[j] + h3[i - j])
	
t = int(input())
for i in range(0, t):
    n = int(input())
    print(h4[n])
```
    但其实我们可以观察其方程也可以得出相同的结论。
    
    对于三阶的汉诺塔，其实可以近似于 2^n爆炸式增长。
    
    所以递推式h4[i] = min(h4[x] * 2 + h3[i - x])
    
    因为到后面2^n就已经很恐怖了，如果我们的x取得很小的话，那么一个幂函数加上去直接爆炸增长。
    那我们就需要权衡一下，将x设置的大一些但是太大了也不行，这样就会使其类似于幂函数了
    
    这里我们应该保证h3[i- x]和h4的级数应该差的不多，
    这里我打了一下表，看了一下 h4[x] 和 h3[i - x]的大小
![image](https://user-images.githubusercontent.com/92497177/168716042-bdb7dbda-d4ac-4056-8ab7-ed3e924eb552.png)

    因为我们假设h4[x]为a, h3[i - x]为b，
    此时a = x * b
    所以总共为(x + 1) * b
    如果那么当i增大的时候，如果我们增大b那就会使得b 变为2 * b
    此时总和为(x + 2) * b
    而如果增大h4，又因为相邻的变化不大，
    所以近似于x
    所以我们选择增大h4的效果会更好。
    
    而我们又不应该过分的使用h4，而应该保证h4和h3差别不会太大。

```diff
!    2022-05-17🥡
```
    
