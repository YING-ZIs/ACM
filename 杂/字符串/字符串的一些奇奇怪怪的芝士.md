#  🛣️ 字符串的一些奇奇怪怪的芝士


#   1.  🧃最小表示法 O(n)
> 可以用最小表示的条件
- 整个字符串是构成一个环的
- 求取所有情况下字典序最小的串
 ------  


   所以对于这个字符串我们就有了许多可以开始的位置，我们可以暴力的去找到最小的
   
   也就是设置两个指针，从指针处开始往后面进行比较，一旦有不同的，就让大的往后面移，这样我们就是能够找出最小的那个。
   
   但是如果有一些情况就可以将其卡掉
   比如说 aaaaaaaac
   下这个暴力的写法就变成O($ n^2 $)了
   
> 优化
> 
![image](https://user-images.githubusercontent.com/92497177/177287927-610f7eb8-8576-4d71-b2d0-eec856a7cfe2.png)  

  对于当前的情况下，我们知道此时b, c不相等，我们需要移动较大的e，但是我们想一下，不论我们把前一个指针移到1-4的区间内
  都是不会有正确答案的，因为我们总可以在x + 4的位置找到一个比他更优的。所以我们此时就不在移动以下，而是直接移动到
  i + k + 1处
  
```C++
int  get_Min(vector<int> a, int n) {
	//i，j分别代表一个字符串的开始位置，k表示两个字符串的相同的长度
	int i = 0, j = 1, k = 0;
	while (i < n && j < n && k < n) {
		if (a[(i + k) % n] == a[(j + k) % n]) {
			k++; 
		} else {
			a[(i + k) % n] > a[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;
			if (i == j) i++;
			k = 0;
		}
		
	}
	
	return min(i, j);
}
```

```diff
!  2022-07-05🎏
```
  
