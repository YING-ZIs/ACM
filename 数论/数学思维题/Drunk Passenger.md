🗞️[Drunk Passenger](https://codeforces.com/gym/103373/problem/D)
===

    假设有n个人
    (1)我们知道对于醉汉，如果他选择我们的位置的话，那就一定会使得我们的位置被占掉，而醉汉不能选择自己的位置；
    所以这种情况下位置被占据的概率是1/(n-1)。
    
    (2)然后另一种情况就是他会占据其他人的位置。
    我们可以推出的是，假设现在的排队情况是 [醉汉，1，2，3，，，，x，，，自己]，此时醉汉占据了x的位置，那么从1号到x-1这个区间
    内的人都是会坐在原位，因为题目中有说，如果位置没有被占据就会归回原位，那也就说明了我们需要开始讨论的是从x到自己这个队列中的人。
    我们从小到大去推。
    
    我们下面讨论的1代表上面的x，我们不再讨论(1)的情况，并且我们先讨论出位置不被占据的概率p,那么被占据的就是1-p：
      <1> 假如只有[醉汉，1，自己]三个人
          那么如果醉汉占据了1的位置，此时我的位置不被占据的概率位 1/2
      <2> *假如只有[醉汉，1，2,自己]三个人,
          因为醉汉占据了1的位置，假如1占据醉汉的位置此时剩下的2会自动归为，我也就会坐回原位。
          那么这种情况下，不被占据的概率为p1 = 1/3
          *如果1占据了2的位置，那么此时就又转化成了<1>中的情况，剩下一个我的位置和醉汉的位置，
          那么这种情况下，不被占据的概率为p2 = (1/3)*(1/2)
          所以总的概率是p1 + p2 = 1/3+(1/3)*(1/2) = 1/2
      <3> 加入有[醉汉，1，2，3，自己]
          如果1占据了醉汉的位置，那么剩下的都会回到原位
          那么p1 = 1/4
          如果1占据了2的位置，那么就和<2>的状态一样了
          所以概率是p2 = (1/4)*(1/2)
          如果1占据了3的位置，那么我们知道2便会自动坐回原位，那么就如同<1>的状态了，
          所以概率是p3 = (1/4)*(1/2)
          那么总的概率是 p1+p2+p3 = 1/2
        
      以此类推，假设有[醉汉,1,2,3,.....n-2,自己](n-2 是因为还有醉汉和自己)
      如果1选择醉汉的位置，那么2到n-2都会回到自己的位置
      那么此时p1 = 1/(n-1)
      如果1，选择2就会恰好转化为上一个状态，而如果他选择3-(n-2)都会转化为之前的
      因为从2到这个人之前的人都会回到原位，而之前的所有状态下自己能回到原位的概率都是1/2
      所以p2 = (n-3)/(n-1)*(1/2) (n-3的原因是除去1，醉汉，自己的位置)
      所以总的概率是p1+p2 = 1/2
      及只要醉汉随便占据后面一个人的位置，那么此种状态下我的位置不被占据的概率都是1/2
    
    所以综合(1)和(2)
    p1 = 1/(n-1)
    p2 = ( (n-2)/(n-1) )*( 1/2 ) (这里n-2的意思是，醉汉随便在除醉汉和我的位置上挑一个人的位置)
    所以总的概率是P =  p1+p2 = n/(2n-2)
    
AC代码
===
```C++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>

using namespace std;
typedef  long long ll;
const int maxn = 2e5+10;

int main()
{
#ifndef ONLINE_JUDGE
freopen("in.txt","r",stdin);
freopen("out.txt","w",stdout);
#endif
    scanf("%d",&n);
    double x = 1.0*n/2/(n-1);
    printf("%lf",x);
	return 0;
}
```
    
```diff
!     ⚔️2021-01-13
```
    
    
    
    
