# 并查集   

🔖首先对于并查集之前一直没有很深的认识，现在想写一些对于他的理解  
 
 ##  普通并查集
    🎈首先对于最普通的并查集无非就是想要让一些元素归为一类，这时我们会让他们的父类具有指向性，
    我们能够根据找其fa[x]，一步一步找到最总的祖宗节点(大哥)。
```C++
    int find_fa(int x){
        if(fa[x] == x) return x;
        return find_fa(fa[x]);
    }
    
```
    这样虽然能够满足我们对于把一些元素归为一类的目的，但是时间上太慢了，因为如果我们定义了一个集合，
    但他们恰好构成了一个链表类型的1->2->3->4->5。那么我们每一次要查询一个元素的大哥的话，每一次都要
    消耗O(n)的时间复杂度，这显眼不够优秀.          
    
    
## 路径压缩并查集
    🩹对于路径压缩的思想可真的是太妙了，这里我们不在考虑一个节点最近的一个大哥，而是直接找到整个帮派的大哥大，
    也就是说在这里fa[x]不是与他直接相连的父代，而是整个树的根
```C++
    int find_fa(int x){
      return fa[x] == x ? x : fa[x] = find_fa(fa[x]);
    }
```
    这就相当于是一个递归，在这里对于每一个元素我们回溯时，那么比他更早进入这个帮派的元素根据递归，他的的fa[x]被我们计算好了，
    于是我们可以直接定义这个元素的fa[x]他父代的祖宗，那么我们对于从这个元素开始到祖宗整条线路就都建立好了，花费了一次O(n)
    的时间，然后以后就都可以O(1)查询就可以了。
![image](https://user-images.githubusercontent.com/92497177/139284332-bc44ec8b-789e-45f7-8f0a-6fbeeebc800a.png)

    
## 边带权并查集
    🥑这种其实就是对于一个并查集的升级，它不仅仅用来表示其父代。
    我们令dist[u]代表当前节u到其祖宗的的距离，(注意这里的距离其实可以类比于第几个进入这个集合的值，而不是构成树的一条链的距离)
    令size[u]代表以当前节点u为祖宗构成的子树的大小

```C++
    int find_fa(int x){
        if(fa[x] == x) 
            return fa[x];
        int y=fa[x];
        fa[x] = find_fa(fa[x]);//路径压缩更新是把之前的所有信息都更新到最新，然后我们这棵树建好了，对于当前的fa即这里的y，再把它真正的祖宗
        dist[x]+=dist[y];//的信息更新一下就可以了
        return fa[x]
    }
    void merge(int x,int y){
        x=find_fa(x);
        y=find_fa(y);
        if(x != y){
            fa[x]=y;
            dist[x]=size[y];//注意如果是如上面构成了联系，那么就类似fa的构造方法，就假设fa就是这棵树的祖宗，我们就更新到当前的fa就可以了
            size[y]+=size[x];//这里size只与其子代有联系，那我们只更新一遍就可以了，
        }
    }
```
    
    
    
    
    
    
    
    
    
    
